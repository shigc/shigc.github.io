{"meta":{"title":"程序员博客","subtitle":"程序员博客","description":"","author":"shigc","url":"https://shigc.top","root":"/"},"pages":[{"title":"404-找不到页面","date":"2018-03-18T21:28:22.000Z","updated":"2018-03-18T21:28:22.000Z","comments":false,"path":"/404.html","permalink":"https://shigc.top/404.html","excerpt":"","text":"404 Page Not Found**对不起，您所访问的页面不存在** **[点击此处](/)**返回首页。 **点击此处**重新搜索结果。"},{"title":"about","date":"2018-03-18T21:28:22.000Z","updated":"2018-03-18T21:28:22.000Z","comments":true,"path":"about/index.html","permalink":"https://shigc.top/about/index.html","excerpt":"","text":"关于我本站基于Hexo搭建而成。非原创文章均带有[转]字标志且会在文中给出原文链接，其他文章均为原创。转载本站博文请保留必要署名，对于没有署名或是故意删除的，本人不再为其提供技术支持，敬请见谅 From China Email: &#x73;&#104;&#105;&#103;&#99;&#x31;&#x30;&#49;&#49;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;"},{"title":"categories","date":"2018-09-30T17:25:30.000Z","updated":"2018-09-30T17:25:30.000Z","comments":true,"path":"categories/index.html","permalink":"https://shigc.top/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T17:25:30.000Z","updated":"2018-09-30T17:25:30.000Z","comments":true,"path":"contact/index.html","permalink":"https://shigc.top/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T21:25:30.000Z","updated":"2018-12-12T21:25:30.000Z","comments":true,"path":"friends/index.html","permalink":"https://shigc.top/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T18:23:38.000Z","updated":"2018-09-30T18:23:38.000Z","comments":true,"path":"tags/index.html","permalink":"https://shigc.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Win32汇编语言程序设计 - 常用指令","slug":"asm4","date":"2022-03-26T10:29:35.000Z","updated":"2022-03-26T10:29:35.000Z","comments":true,"path":"2022/03/26/asm4/","link":"","permalink":"https://shigc.top/2022/03/26/asm4/","excerpt":"","text":"常用指令1. 数据传送指令1.1 MOV从源操作数向目的操作数复制数据 用法： MOV DST,SRC 说明： 两个操作数尺寸必须一致。例如MOV EBX,AX是错误的 两个操作数不能同时为内存操作数。例如MOV [var],[2000H]是错误的 目的操作数不能是CS，EIP和IP。例如MOV CS,AX是错误的 立即数不能直接送至段寄存器。例如MOV SS,2000H是错误的 1.2 MOVZX将源操作数内容复制到目的操作数并将该值零扩展到16位或者32位 用法： MOVZX DST,SRC 说明： 只适用于无符号整数 目的操作数必须是寄存器 1.3 MOVSX将源操作数内容复制到目的操作数并将该值符号扩展到16位或者32位 用法： MOVZX DST,SRC 说明： 只适用于有符号整数 目的操作数必须是寄存器 1.4 LAHF将EFLAGS寄存器的低字节复制到AH寄存器中 用法： LAHF 说明： 被复制的标志包含符号标志，零标志，辅助进位标志，奇偶标志和进位标志 1.5 SAHF复制AH寄存器的值到EFLAGS寄存器的低字节 用法： SAHF 说明： 用于恢复FLAGS低字节标记位 1.6 XCHG交换两个操作数的内容 用法： XCHG SRC1,SRC2 说明： 不接受立即操作数，其它和MOV指令规则一致 1.7 直接偏移操作数对变量地址进行偏移得到新的地址 用法： var+n 说明： 偏移数目n为字节，所以在数组元素大小不是1字节时，取下一个元素偏移也不是1","categories":[{"name":"assembly","slug":"assembly","permalink":"https://shigc.top/categories/assembly/"}],"tags":[{"name":"assembly","slug":"assembly","permalink":"https://shigc.top/tags/assembly/"}]},{"title":"lua脚本语言入门","slug":"lua1","date":"2022-02-26T14:00:10.000Z","updated":"2022-02-26T14:00:10.000Z","comments":true,"path":"2022/02/26/lua1/","link":"","permalink":"https://shigc.top/2022/02/26/lua1/","excerpt":"","text":"","categories":[{"name":"lua","slug":"lua","permalink":"https://shigc.top/categories/lua/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://shigc.top/tags/programming/"},{"name":"lua","slug":"lua","permalink":"https://shigc.top/tags/lua/"}]},{"title":"Wireshark从入门到精通","slug":"Wireshark从入门到精通1","date":"2022-02-26T09:00:17.000Z","updated":"2022-02-26T09:00:17.000Z","comments":true,"path":"2022/02/26/Wireshark从入门到精通1/","link":"","permalink":"https://shigc.top/2022/02/26/Wireshark%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A1/","excerpt":"","text":"Wireshark从入门到精通","categories":[{"name":"wireshark","slug":"wireshark","permalink":"https://shigc.top/categories/wireshark/"}],"tags":[{"name":"Wireshark","slug":"Wireshark","permalink":"https://shigc.top/tags/Wireshark/"},{"name":"network","slug":"network","permalink":"https://shigc.top/tags/network/"}]},{"title":"Win32汇编语言程序设计 - 基本执行环境","slug":"asm3","date":"2022-02-20T10:29:35.000Z","updated":"2022-02-20T10:29:35.000Z","comments":true,"path":"2022/02/20/asm3/","link":"","permalink":"https://shigc.top/2022/02/20/asm3/","excerpt":"","text":"基本寄存器 通用寄存器 名称 功能 EAX 累加器(Accumulator)，可用于乘、除、输入&#x2F;输出等操作，它们的使用频率很高 EBX 基地址寄存器(BaseRegister)，可作为存储器指针来使用 ECX 计数寄存器(CountRegister)，在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数 EDX 数据寄存器(DataRegister)，进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I&#x2F;O的端口地址 EBP&#x2F;ESP 指针寄存器(PointerRegister)，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便 ESI&#x2F;EDI 变址寄存器(IndexRegister)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便 段寄存器 名称 功能 CS 代码段寄存器(CodeSegmentRegister)，其值为代码段的段值 SS 堆栈段寄存器(StackSegmentRegister)，其值为堆栈段的段值 DS 数据段寄存器(DataSegmentRegister)，其值为数据段的段值 ES 附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值 FS 附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值 GS 附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值 状态标志寄存器（EFLAGS） 进位标志（CF）：在无符号算术运算的结果太大而超过目的操作数的内存大小时置位 溢出标志（OF）：在有符号算术运算的结果太大或太小而超过目的操作数内存大小时置位 符号标志（SF）：在算术或者逻辑运算的结果为负数时置位 零标志（ZF）：在算术或者逻辑运算的结果为0时置位 辅助进位标志（AC）：在算术运算导致8位操作数的位3或者位4产生进位时置位 奇偶标志（PF）：结果的最低有效位字节为1的位的数目为偶数时置位，否则PF复位。 指令指针寄存器（EIP） EIP寄存器存放下一条要执行指令的地址，部分机器指令可以修改EIP，使程序分支转移到新的地址执行","categories":[{"name":"assembly","slug":"assembly","permalink":"https://shigc.top/categories/assembly/"}],"tags":[{"name":"assembly","slug":"assembly","permalink":"https://shigc.top/tags/assembly/"}]},{"title":"Win32汇编语言程序设计 - 基础组成","slug":"asm2","date":"2022-01-22T10:29:11.000Z","updated":"2022-01-22T10:29:11.000Z","comments":true,"path":"2022/01/22/asm2/","link":"","permalink":"https://shigc.top/2022/01/22/asm2/","excerpt":"","text":"一个基础的汇编语言示例： 1234567891011121314151617181920212223242526TITLE 汇编语言示例程序; 程序的描述：打印字符串&quot;hello world!\\n&quot;; 作者：shigc; 创建日期：2022-02-13.386.model flat,stdcalloption casemap :none ; 大小写敏感.stack 4096include masm32.incinclude kernel32.incincludelib masm32.libincludelib kernel32.lib.data szHello BYTE &quot;hello world!&quot;,0dh,0ah,0.codemain PROC invoke StdOut, addr szHello invoke ExitProcess,0main ENDPEND main 说明： TITLE伪指令将整行标记为注释，改行可以放置任何东西 分号是注释符号，编译器会忽略分号右边的所有文本 .386 指出该程序要求的最低CPU（Intel 386） .model 伪指令用于设置程序的内存模型，flat为Windows程序使用的模式(代码和数据使用同一个4GB段)，stdcall为API调用时右边的参数先入栈 option casemap :none 设置符号（函数和变量）大小写敏感，但是汇编指令还是不区分大小写的 .stack 4096 设置堆栈大小为4096，默认值1024 include masm32.inc 用于从masm32.inc文件中复制必需的定义和设置信息，查找目录为INCLUDE环境变量定义的目录 includelib masm32.lib用于链接过程中从对应静态库中链接对应的符号，查找目录为LIB环境变量定义的目录 .data 伪指令标识了程序包含变量的区域 .code 伪指令标识了程序包含指令的区域 PROC 伪指令用于标识一个过程的开始 invoke 伪指令用于将参数入栈，并调用过程，addr伪指令用于传递指针参数 ENDP 伪指令用于标识一个过程的结束 END 伪指令用于标明该行是汇编源程序最后一行，后面的所有内容不参与编译 基本组成： 汇编指令 机器码的助记符，有对应的机器码 伪指令 没有对应的机器码，由编译器执行，计算机不执行 其他符号 如+,-,*,&#x2F;等，由编译器识别，没有对应的机器码 基本元素 整数常量 整数常量由符号（可选）开头，后跟一个或多个数字以及一个表示数制基数的字符后缀:[{+|-}] 数字[基数]。以字母开头的十六进制常量前面必须添加一个0，以防止汇编器将其解释为标识符。 基数 进制 基数 进制 h 十六进制 r 编码实数 q&#x2F;o 八进制 t 十进制（可选） d 十进制 y 二进制（可选） b 二进制 整数表达式 整数表达式是包含整数值和算术运算符的数学表达式。整数表达式计算的结果必须是能够以32个数据位存储的整数（0~FFFFFFFFh）。 运算符 名称 优先级 () 圆括号 1 +, - 一元加、减（符号位） 2 *, &#x2F; 乘、除 3 MOD 取余数 3 +, - 加、减 4 实数常量 有两种类型的实数常量：十进制实数和编码（十六进制）实数。 十进制实数常量由符号( sign）、整数（integer）部分、小数点、表示小数的整数和指数（exponent）部分组成 12345示例：2.+3.0-44.2E+0526.E5 编码实数：编码实数是以16进制数表示一个实数的，遵循IEEE浮点数格式 12示例：+1.0 可以表示为3F800000r 精度 说明 单精度 32 位：1 位符号位，8 位阶码，23 位为有效数字的小数部分。大致的规格化范围：2-126 〜2127 。也被称为短实数 (short real) 双精度 64 位：1 位符号位，11 位阶码，52 位为有效数字的小数部分。大致的规格化范围：2-1022 〜21023 。也被称为长实数 (longreal) 扩展双精度 80 位：1 位符号位，15 位阶码，1 位为整数部分，63 位为有效数字的小数部分。大致的规格化范围：2-16382〜216383。也被称为扩展实数 (extended real) 字符常量 字符常量是以单引号或双引号括起来的单个字符。汇编器将其转换为与字符对应的二进制数ASCII码。 字符串常量 字符串常量是以单引号或双引号括起来的串字符。 保留字 指令助记符，如MOV，ADD，和MUL等 伪指令，用于告诉MASM如何编译程序 属性，用于为变量和操作数提供有关尺寸以及使用方式的信息，如BYTE，WORD等 运算符，用在常量表达式中 预定义符号，如@data，在编译时返回整数常量值。 标识符 标识符是程序员选择的名字，用来标识变量、常量、过程或代码标号。创建标识符时要注意以下几点： 标识符可包含1~247个字符。 标识符大小写不敏感（MASM默认）。 标识符的第一个字符必须是字母（A～Z和a～z）、下划线（_）、@、？或$，后续字符可以是数字。 标识符不能与汇编器的保留字相同。 伪指令 伪指令是内嵌在程序源代码中，由汇编器识别并执行相应动作的命令。与真正的指令不同，伪指令在程序运行时并不执行。伪指令可用于定义变量、宏以及过程，可用于命名段以及执行许多其他与汇编器相关的簿记任务。MASM 中伪指令大小写不敏感，如.data，.DATA 和.Data 是等价的 指令 汇编语言中的指令是一条汇编语句，在程序被汇编后就变成可执行的机器指了。汇编器把汇编指令翻译成机器语言字节码，在运行时可以加载至内存由处理器执行。一条汇编指令包含4个基本部分： 标号（可选） 指令助记符（必需） 操作数（通常是必需的） 注释（可选） NOP操作符 最安全的指令是NOP（no operation），一条NOP 指令占用一个字节的存储，什么也不做。有时编译器或汇编器使用NOP指令把代码对齐到偶数地址边界。","categories":[{"name":"assembly","slug":"assembly","permalink":"https://shigc.top/categories/assembly/"}],"tags":[{"name":"assembly","slug":"assembly","permalink":"https://shigc.top/tags/assembly/"}]},{"title":"Win32汇编语言程序设计 - 环境搭建","slug":"asm1","date":"2022-01-20T10:28:55.000Z","updated":"2022-01-20T10:28:55.000Z","comments":true,"path":"2022/01/20/asm1/","link":"","permalink":"https://shigc.top/2022/01/20/asm1/","excerpt":"","text":"使用visual studio 2010和masm32搭建win32汇编语言开发环境 安装masm32： 从官网 http://www.masm32.com 下载最新的安装包 以管理员权限运行安装程序 安装AsmHighlighter：下载地址https://download.csdn.net/download/barrysgy/10718561 使用visual studio 2010创建项目： 新建一个空白项目 选中项目-右键-生成自定义-选择masm 项目属性-配置属性-链接器-系统-子系统修改为控制台 (&#x2F;SUBSYSTEM:CONSOLE) 项目属性-配置属性-Microsoft Macro Assembler-General-Include Paths添加masm32的include目录 项目属性-配置属性-链接器-常规-附加附加库目录添加masm32的lib目录 新建一个hello.asm文件 1234567891011121314151617.486.model flat, stdcalloption casemap :none ; case sensitiveinclude windows.incinclude masm32.incinclude kernel32.incinclude macros.asmincludelib masm32.libincludelib kernel32.lib.codestart: print &quot;Hello world&quot; exitend start 生成解决方案 Tips: 上面步骤如果没有出现Microsoft Macro Assembler配置，请先添加一个.asm后缀结尾的文件到项目","categories":[{"name":"assembly","slug":"assembly","permalink":"https://shigc.top/categories/assembly/"}],"tags":[{"name":"assembly","slug":"assembly","permalink":"https://shigc.top/tags/assembly/"}]},{"title":"vue环境搭建","slug":"前端开发1-vue安装","date":"2021-11-20T10:18:40.000Z","updated":"2021-11-20T10:18:40.000Z","comments":true,"path":"2021/11/20/前端开发1-vue安装/","link":"","permalink":"https://shigc.top/2021/11/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%911-vue%E5%AE%89%E8%A3%85/","excerpt":"","text":"1. vue环境搭建1.1 安装node.jsNode.js下载地址，选择对应平台下载安装，使用默认设置安装即可 1.2 设置node.js全局和缓存路径（可选） 在nodejs安装路径下，新建node_global和node_cache两个文件夹 设置缓存文件夹 1npm config set cache &quot;&lt;nodejs安装路径&gt;\\node_cache&quot; 设置全局模块存放路径 12# 设置成功后，之后用命令npm install XXX -g安装以后模块会放在设置的node_global目录里面npm config set prefix &quot;&lt;nodejs安装路径&gt;\\node_global&quot; 1.3 安装cnpm(淘宝镜像)1npm install -g cnpm --registry=https://registry.npm.taobao.org 1.4 设置环境变量添加NODE_PATH环境变量，值为&lt;nodejs安装路径&gt;\\node_global\\node_modules 并添加&lt;nodejs安装路径&gt;\\node_global到PATH中 1.5 安装vue1cnpm install vue -g 1.6 安装vue-cli 脚手架1cnpm install vue-cli -g 1.7 全局安装webpack1cnpm install webpack -g","categories":[{"name":"vue","slug":"vue","permalink":"https://shigc.top/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://shigc.top/tags/vue/"},{"name":"web","slug":"web","permalink":"https://shigc.top/tags/web/"}]},{"title":"烽火HG2543C1光猫破解教程","slug":"article4","date":"2021-10-20T10:28:13.000Z","updated":"2021-10-20T10:28:13.000Z","comments":true,"path":"2021/10/20/article4/","link":"","permalink":"https://shigc.top/2021/10/20/article4/","excerpt":"","text":"1. HG2543C1光猫路由模式改桥接模式1.1 打开光猫telnet功能浏览器访问 http://192.168.1.1:8080/cgi-bin/telnetenable.cgi?telnetenable=1 1.2 telnet进入光猫获取telecomadmin密码登录用户名root，密码是默认wifi密码+默认useradmin密码，具体看光猫背面cat &#x2F;flash&#x2F;cfg&#x2F;agentconf&#x2F;factory.conf 查看telecomadmin密码cat &#x2F;flash&#x2F;cfg&#x2F;app_conf&#x2F;pppoe&#x2F;chap-secrets 查看宽带账号和密码 1.3 使用telecomadmin账号登录浏览器访问 http://192.168.1.1:8080/cgi-bin/login.htm.cgi打开网络–宽带设置，设置2_INTERNET_B_VID_xxxx连接方式为桥接，具体见下图","categories":[{"name":"路由器","slug":"路由器","permalink":"https://shigc.top/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"tags":[{"name":"光猫","slug":"光猫","permalink":"https://shigc.top/tags/%E5%85%89%E7%8C%AB/"},{"name":"HG2543C1","slug":"HG2543C1","permalink":"https://shigc.top/tags/HG2543C1/"}]},{"title":"正则表达式速查","slug":"article3","date":"2021-09-20T10:27:57.000Z","updated":"2021-09-20T10:27:57.000Z","comments":true,"path":"2021/09/20/article3/","link":"","permalink":"https://shigc.top/2021/09/20/article3/","excerpt":"","text":"正则表达式速查表 字符 描述 \\b 匹配一个单词边界，例如：”er\\b”可以匹配”never”中的”er”，但不能匹配”verb”中的”er” \\B 匹配非单词边界，例如：”er\\B”能匹配”verb”中的”er”，但不能匹配”never”中的”er” \\d 匹配一个数字字符，等价于[0-9] \\D 匹配一个非数字字符，等价于[^0-9] \\w 匹配包括下划线的任何单词字符，等价于”[A-Za-z0-9_]” \\W 匹配任何非单词字符，等价于”[^A-Za-z0-9_]“ \\s 匹配任何空白字符，包括空格、制表符、换页符等等，等价于[ \\f\\n\\r\\t\\v] \\S 匹配任何非空白字符，等价于[^ \\f\\n\\r\\t\\v] \\t 匹配一个水平制表符，等价于\\x09和\\cI和\\11 \\n 匹配一个换行符，等价于\\x0a和\\cJ和\\12 \\v 匹配一个垂直制表符，等价于\\x0b和\\cK和\\13 \\f 匹配一个换页符，等价于\\x0c和\\cL和\\14 \\r 匹配一个回车符，等价于\\x0d和\\cM和\\15 \\num 匹配num，其中num是一个正整数，对所获取的匹配的引用，例如，”(.)\\1”匹配两个连续的相同字符， \\xnn 匹配ASCII代码中十六进制代码为nn的字符，十六进制转义值必须为确定的两个数字长，例如：”\\x41”匹配”A”，”\\x041”则等价于”\\x04&amp;1”，正则表达式中可以使用ASCII编码 \\nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml，例如：字符串为:AA25\\nbb23，正则表达式为”(.)\\12”，匹配的结果是5&lt;换行符&gt;，而不是AA2和bb2，后者正确的正则表达式为”(.)\\1[2]” \\unnnn 匹配Unicode代码中十六进制代码为nnnn的字符 \\cx 匹配由x指明的控制字符，例如：\\cM匹配一个Control-M或回车符，x的值必须为A-Z或a-z之一，否则，将c视为一个原义的”c”字符 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符，例如，”n”匹配字符”n”，”\\n”匹配一个换行符 ^ 匹配输入字符串的开始位置，如果设置了RegExp对象的Multiline属性，^也匹配”\\n”或”\\r”之后的位置 $ 匹配输入字符串的结束位置，如果设置了RegExp对象的Multiline属性，$也匹配”\\n”或”\\r”之前的位置 * 匹配前面的子表达式零次或多次，例如：zo能匹配”z”以及”zoo”，等价于{0,} + 匹配前面的子表达式一次或多次，例如，”zo+”能匹配”zo”以及”zoo”，但不能匹配”z”，+等价于{1,} ? 匹配前面的子表达式零次或一次，例如，”do(es)?”可以匹配”does”或”does”中的”do”，?等价于{0,1} {n} n是一个非负整数，至少匹配n次，例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o，”o{1,}”等价于”o+”，”o{0,}”则等价于”o*” {n,m} m和n均为非负整数，其中n&lt;&#x3D;m，最少匹配n次且最多匹配m次，例如，”o{1,3}”将匹配”fooooood”中的前三个o，”o{0,1}”等价于”o?”，请注意在逗号和两个数之间不能有空格 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的，非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串，例如，对于字符串”oooo”，”o+?”将匹配单个”o”，而”o+”将匹配所有”o” . 匹配除”\\n”之外的任何单个字符，要匹配包括”\\n”在内的任何字符，请使用像”(.|\\n)”的模式 (pattern) 匹配pattern并获取这一匹配，所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性，要匹配圆括号字符，请使用”(“或”)“ (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用，这在使用或字符”(|)”来组合一个模式的各个部分是很有用，例如”industr(?:y|ies)”就是一个比”industry|industries”更简略的表达式 (?&#x3D;pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用，例如，”Windows(?&#x3D;95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”，预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用，例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”，预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;&#x3D;pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反，例如，”(?&lt;&#x3D;95|98|NT|2000)Windows”能匹配”2000Windows”中的”Windows”，但不能匹配”3.1Windows”中的”Windows” (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反，例如”(?&lt;!95|98|NT|2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows” x|y 匹配x或y，例如，”z|food”能匹配”z”或”food”，”(z|)ood”则匹配”zood”或”food” [xyz] 字符集合，匹配所包含的任意一个字符，例如，”[abc]”可以匹配”plain”中的”a” [^xyz] 负值字符集合，匹配未包含的任意字符，例如，”[^abc]“可以匹配”plain”中的”p” [a-z] 字符范围，匹配指定范围内的任意字符，例如，”[a-z]“可以匹配”a”到”z”范围内的任意小写字母字符 [^a-z] 负值字符范围，匹配任何不在指定范围内的任意字符，例如，”[^a-z]“可以匹配任何不在”a”到”z”范围内的任意字符 正则表达式模式修正符(Python) 符号 含义 I 配置时忽略大小写 M 多行匹配，系统默认将字符串作为单一的一”行”字符所组成的（甚至其中包含有换行符也是如此），开启该模式之后^可以匹配每一行的开头 L 做本地化识别匹配 U 根据Unicode字符及解析字符 S 让.匹配包括换行符，即用了该模式之后，’.’可以匹配任意字符 常见正则表达式 名称 表达式 中文汉字 [\\u4e00-\\u9fa5] 空白行 \\n\\s*\\r email地址 \\ [\\w!#$%&amp;’+&#x2F;&#x3D;?^_`{|}-]+(?:.[\\w!#$%&amp;’*+&#x2F;&#x3D;?^_`{|}-]+)@(?:[\\w](?:[\\w-]*[\\w])?.)+[\\w](?:[\\w-]*[\\w])? URL [a-zA-Z]+://[^\\s]* 国内电话号码 \\d{3}-\\d{8}|\\d{4}-\\d{7,8} QQ号 [1-9][0-9]{4,} 中国邮政编号 [1-9]\\d{5}(?!\\d) 18位身份证号 ^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 正整数 ^[1-9]\\d*$ 整数 ^-?[1-9]\\d*$ 非负整数 ^[1-9]\\d*|0$ 正浮点数 ^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$ 参考链接：正则表达式速查表常见正则表达式在线正则表达式测试工具","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://shigc.top/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"regex","slug":"regex","permalink":"https://shigc.top/tags/regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://shigc.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Python scrapy自动切换HTTP代理","slug":"article2","date":"2021-08-20T10:27:28.000Z","updated":"2021-08-20T10:27:28.000Z","comments":true,"path":"2021/08/20/article2/","link":"","permalink":"https://shigc.top/2021/08/20/article2/","excerpt":"","text":"使用Scrapy中间件动态修改代理IP 常见的反爬虫及应对策略 通过检查Headers中的User-Agent或者Referer（为了防止盗链）值，应对策略： 在请求的时候动态修改User-Agent值，或者将Referer设置为目标网站的域名地址 基于用户行为进行反爬虫，同一个IP很短的时间内多次进行访问，应对策略： 爬取页面的时候设置阈值，每次抓取完页面sleep一段时间 使用IP代理，在抓取页面的时候动态的切换IP 只抓取动态请求的数据，不直接抓取整个页面 Scrapy中间件的使用1.创建一个中间件对象，并实现process_request(request, spider)方法： 123456class HttpProxyMiddleware(object): def process_request(self, request, spider): proxy = HttpProxy() #这里可以设置请求的user-agent #request.headers.setdefault(&#x27;User-Agent&#x27;, &quot;Your user agent!&quot;) request.meta[&quot;proxy&quot;] = proxy.get_random_ip() 这里的HttpProxy是写好的获取代理IP的工具类，返回代理格式：[协议]://[IP]:[PORT] 2.在setting.py中配置创建的中间件 12345DOWNLOADER_MIDDLEWARES = &#123; &#x27;myprojects.middlewares.HttpProxyMiddleware&#x27;: 300&#125; 参考资料：github上的HttpProxyMiddleware","categories":[{"name":"Python","slug":"Python","permalink":"https://shigc.top/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shigc.top/tags/python/"},{"name":"scrapy","slug":"scrapy","permalink":"https://shigc.top/tags/scrapy/"}]},{"title":"安卓手机用作电脑的HTTP代理服务器","slug":"article1","date":"2021-07-20T10:27:14.000Z","updated":"2021-07-20T10:27:14.000Z","comments":true,"path":"2021/07/20/article1/","link":"","permalink":"https://shigc.top/2021/07/20/article1/","excerpt":"","text":"目前电脑上的免费VPN软件比较难找，但是安卓上的免费VPN软件很多，所以考虑手机翻墙后作为电脑端的HTTP代理服务器，让电脑端也可以科学上网 手机端设置： 下载安装Termux，google play上可以直接下载 在Termux上安装Python 1$ apt install python 安装HTTP代理服务器脚本 1$ pip install proxy.py 运行HTTP代理服务器（默认端口是8899，可以用port参数指定端口） 1$ proxy.py --hostname &lt;手机局域网IP地址&gt; 备注： hostname参数不配置的话，默认使用的IP是127.0.0.1，这时手机只能作为本机的代理服务器 手机和电脑必须在同一个局域网下（保证手机和电脑能建立连接） 电脑端设置： 设置IE的代理:Internet选项–连接–局域网设置–代理服务器，地址为手机局域网地址，端口8899，你也可以安装一些快速切换代理的插件来设置，这里就不多说明了 Tips:手机通过电脑代理上网也可以类似地进行操作，在电脑上安装Python和proxy.py，然后运行proxy.py 参考文章：知乎：用Android手机做电脑的HTTP代理服务器","categories":[{"name":"Android","slug":"Android","permalink":"https://shigc.top/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://shigc.top/tags/android/"},{"name":"proxy","slug":"proxy","permalink":"https://shigc.top/tags/proxy/"}]},{"title":"程序的编译和链接","slug":"c_progamming1","date":"2021-06-20T10:26:21.000Z","updated":"2021-06-20T10:26:21.000Z","comments":true,"path":"2021/06/20/c_progamming1/","link":"","permalink":"https://shigc.top/2021/06/20/c_progamming1/","excerpt":"","text":"1. 程序的编译编译过程分为两个阶段：编译和汇编，而源文件的编译过程又包含两个主要阶段：编译预处理和编译 预编译：编译预处理读取源代码，对其中的伪指令和特殊符号进行处理。宏展开、引用文件展开等动作均在这个过程完成。 1234567891011//first.c#include &lt;stdio.h&gt;#include &quot;api.h&quot;#define SYS_NAME &quot;linux&quot;int main(int argc, char **argv)&#123; printf(&quot;hello world! %s\\n&quot;, SYS_NAME); print_hello();&#125; 预编译将.c文件转换成.i文件，使用的gcc命令时gcc -E，通过gcc -E first.c -o first.i 生成预编译文件，可以看到源码中引用的头文件中对应定义被”内联“宏展开 12345678910111213141516171819202122......extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));# 840 &quot;/usr/include/stdio.h&quot; 3 4extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));# 868 &quot;/usr/include/stdio.h&quot; 3 4# 2 &quot;first.c&quot; 2# 1 &quot;api.h&quot; 1# 1 &quot;api.h&quot;void print_hello();# 3 &quot;first.c&quot; 2int main(int argc, char **argv)&#123; printf(&quot;hello world! %s\\n&quot;, &quot;linux&quot;); print_hello();&#125; 编译：编译程序索要做的工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码来表示或汇编代码 编译将.c&#x2F;.h文件转换成.s文件，使用的gcc命令是gcc -S，通过gcc -S first.i -o first.s命令将预编译文件生成汇编代码 123456789101112131415161718192021222324252627282930313233343536 .file &quot;first.c&quot; .text .section .rodata.LC0: .string &quot;linux&quot;.LC1: .string &quot;hello world! %s\\n&quot; .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp movl %edi, -4(%rbp) movq %rsi, -16(%rbp) leaq .LC0(%rip), %rsi leaq .LC1(%rip), %rdi movl $0, %eax call printf@PLT movl $0, %eax call print_hello@PLT movl $0, %eax leave .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .ident &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 汇编：汇编过程实际上是指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个源代码，都将最终进过这一处理而得到相应的目标文件，目标文件是为二进制文件，通常为.o文件。 汇编将.s文件转换成.o文件，使用的gcc命令时gcc -c，编译命令是as。通过as first.s -o first.o命令把汇编代码生成机器语言代码，使用objdump -t first.o 命令查看生成的符号表。 123456789101112131415first.o： 文件格式 elf64-x86-64SYMBOL TABLE:0000000000000000 l df *ABS* 0000000000000000 first.c0000000000000000 l d .text 0000000000000000 .text0000000000000000 l d .data 0000000000000000 .data0000000000000000 l d .bss 0000000000000000 .bss0000000000000000 l d .rodata 0000000000000000 .rodata0000000000000000 l d .note.GNU-stack 0000000000000000 .note.GNU-stack0000000000000000 l d .eh_frame 0000000000000000 .eh_frame0000000000000000 l d .comment 0000000000000000 .comment0000000000000000 g F .text 0000000000000038 main0000000000000000 *UND* 0000000000000000 _GLOBAL_OFFSET_TABLE_0000000000000000 *UND* 0000000000000000 printf0000000000000000 *UND* 0000000000000000 print_hello 2. 程序的链接汇编程序生成的目标文件并不能直接执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另外一个源文件中定义的某个符号；在程序中可能调用了某个库函数等等。所有这些问题都需要经过链接程序处理才得以解决 程序的链接是将多个.o文件相应的段进行合并，建立映射关系并且合并符号表，进行符号解析，符号解析完成后就是给符号分配的虚拟地址。 将分配好的虚拟地址与符号表中定义的符号一一对应起来，使其成为正确的地址，使代码段的指令可以根据符号的地址执行相应的操作，最后由链接器生成可执行文件。 链接处理可以分为静态链接和动态链接。linux下静态链接生成是.a文件，动态链接生成是.so文件。 静态链接方式生成程序 123gcc -c api.c -o api.oar rcs -o api.a api.ogcc -static -g -o first_s first.c api.a","categories":[{"name":"programming","slug":"programming","permalink":"https://shigc.top/categories/programming/"}],"tags":[{"name":"c","slug":"c","permalink":"https://shigc.top/tags/c/"},{"name":"programming","slug":"programming","permalink":"https://shigc.top/tags/programming/"}]},{"title":"Git使用方法和推送项目到远程仓库","slug":"git001","date":"2021-05-20T10:25:31.000Z","updated":"2021-05-20T10:25:31.000Z","comments":true,"path":"2021/05/20/git001/","link":"","permalink":"https://shigc.top/2021/05/20/git001/","excerpt":"","text":"本文将介绍git的基本使用方法，以及讲解如何使用git上传项目到远程仓库，这里以码云为例. 1. 基本配置1.1 配置用户名和邮箱12$ git config --global user.name &quot;username&quot; #配置用户名$ git config --global user.email &quot;email&quot; #配置邮箱 1.2 生成并部署SSH公钥1$ ssh-keygen -t rsa -C &quot;email&quot; #根据邮箱生成SSH密钥，-C参数是可选的 默认生成位置是~&#x2F;.ssh&#x2F;id_rsa.pub，然后将id_rsa.pub添加到远程仓库中，码云网站公钥添加地址 1.3 创建远程仓库打开新建项目创建新的仓库，github除了可以在网页创建项目外，也可以通过命令行创建项目 1$ curl -u &#x27;用户名&#x27; https://api.github.com/user/repos -d &#x27;&#123;&quot;name&quot;:&quot;仓库名&quot;&#125;&#x27; 2. git项目初始化与连接远程仓库2.1 初始化本地仓库1$ git init #切换到项目所在目录，然后执行该命令 2.2 连接远程仓库1$ git remote add origin https://gitee.com/username/xxx.git 2.3 从远程仓库更新到本地1$ git pull origin master #更新.gitignore和README.md等初始文件到本地 2.4 代码更新到本地仓库12$ git add . #上传所有文件$ git commit -m &#x27;First commit&#x27; 2.5 本地仓库代码推送到远程仓库1$ git push origin master #如果2.3没有执行可能会报错，可以使用-f参数强制舍弃远程仓库上的文件 FAQ: 执行git push origin master提示“origin does not to be a git repository”重新输入git remote add origin &#103;&#105;&#x74;&#x40;&#x67;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;:yourusername&#x2F;test.git 然后再执行上面的命令 git忽略已经提交的文件有时候我们添加.gitignore文件之前已经提交过了文件。.gitignore只能忽略那些原来没有被track的文件（自添加以后，从未 add 及 commit 过的文件），如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。就需要执行123$ git rm -r --cached . #删除当前目录所有文件追踪状态$ git add . #为当前目录文件添加追踪状态$ git commit -m &quot;fixed untracked files&quot;","categories":[{"name":"git","slug":"git","permalink":"https://shigc.top/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://shigc.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://shigc.top/tags/github/"}]},{"title":"Oracel Linux上安装docker","slug":"Oracle Linux安装docker","date":"2021-04-20T10:22:31.000Z","updated":"2021-04-20T10:22:31.000Z","comments":true,"path":"2021/04/20/Oracle Linux安装docker/","link":"","permalink":"https://shigc.top/2021/04/20/Oracle%20Linux%E5%AE%89%E8%A3%85docker/","excerpt":"","text":"Oracel Linux上安装docker1. 安装必须的基本工具yum install -y yum-utils 2. 添加docker镜像repo123yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 3. 更新yum缓存yum makecache fast 4. 安装dockeryum install docker-ce docker-ce-cli containerd.io 5. 运行docker守护进程systemctl start docker FAQ: 安装docker时提示Requires: fuse-overlayfs &gt;&#x3D; 0.7和Requires: slirp4netns &gt;&#x3D; 0.4的解决方法 添加下面内容到&#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo最前面，然后执行yum -y install slirp4netns fuse-overlayfs container-selinux 12345[centos-extras]name=Centos extras - $basearchbaseurl=http://mirror.centos.org/centos/7/extras/x86_64enabled=1gpgcheck=0","categories":[{"name":"docker","slug":"docker","permalink":"https://shigc.top/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://shigc.top/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://shigc.top/tags/docker/"}]},{"title":"quagga的安装和使用","slug":"quagga-01","date":"2021-03-20T10:22:10.000Z","updated":"2021-03-20T10:22:10.000Z","comments":true,"path":"2021/03/20/quagga-01/","link":"","permalink":"https://shigc.top/2021/03/20/quagga-01/","excerpt":"","text":"Quagga软件原名是Zebra是由一个日本开发团队编写的一个以GNU版权方式发布的软件 1.下载源码并编译安装：1234[root@centos code]# git clone https://gitee.com/opensi/quagga.git[root@centos code]# cd quagga/[root@centos code]# ./configure --enable-tcp-zebra --enable-mpls --enable-ldpd --enable-vtysh --enable-user=root --enable-group=root --enable-vty-group=root[root@centos quagga]# make &amp;&amp; make install 2.复制配置文件到quagga默认配置目录下123[root@centos quagga]# cp zebra/zebra.conf.sample /usr/local/etc/[root@centos quagga]# cp ospfd/ospfd.conf.sample /usr/local/etc/[root@centos quagga]# cp ldpd/ldpd.conf.sample /usr/local/etc/ 3.启动相关进程123[root@centos quagga]# zebra -d[root@centos quagga]# ospfd -d[root@centos quagga]# ldpd -d tips:1、如果vmware无法ping通windows，但是windows可以ping通vware虚拟机，需要关闭windows防火墙2、如果zebra收到报文但是ospf无法建立，需要关闭系统防火墙 参考文章：Linux上实现mpls，ldpd（Quagga）完整步骤","categories":[{"name":"Quagga","slug":"Quagga","permalink":"https://shigc.top/categories/Quagga/"}],"tags":[{"name":"quagga","slug":"quagga","permalink":"https://shigc.top/tags/quagga/"},{"name":"router","slug":"router","permalink":"https://shigc.top/tags/router/"}]},{"title":"博客说明","slug":"README","date":"2021-02-20T10:19:11.000Z","updated":"2021-02-20T10:19:11.000Z","comments":true,"path":"2021/02/20/README/","link":"","permalink":"https://shigc.top/2021/02/20/README/","excerpt":"","text":"blog基于markdown的个人笔记","categories":[{"name":"readme","slug":"readme","permalink":"https://shigc.top/categories/readme/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://shigc.top/tags/blog/"},{"name":"readme","slug":"readme","permalink":"https://shigc.top/tags/readme/"}]}],"categories":[{"name":"assembly","slug":"assembly","permalink":"https://shigc.top/categories/assembly/"},{"name":"lua","slug":"lua","permalink":"https://shigc.top/categories/lua/"},{"name":"wireshark","slug":"wireshark","permalink":"https://shigc.top/categories/wireshark/"},{"name":"vue","slug":"vue","permalink":"https://shigc.top/categories/vue/"},{"name":"路由器","slug":"路由器","permalink":"https://shigc.top/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://shigc.top/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Python","slug":"Python","permalink":"https://shigc.top/categories/Python/"},{"name":"Android","slug":"Android","permalink":"https://shigc.top/categories/Android/"},{"name":"programming","slug":"programming","permalink":"https://shigc.top/categories/programming/"},{"name":"git","slug":"git","permalink":"https://shigc.top/categories/git/"},{"name":"docker","slug":"docker","permalink":"https://shigc.top/categories/docker/"},{"name":"Quagga","slug":"Quagga","permalink":"https://shigc.top/categories/Quagga/"},{"name":"readme","slug":"readme","permalink":"https://shigc.top/categories/readme/"}],"tags":[{"name":"assembly","slug":"assembly","permalink":"https://shigc.top/tags/assembly/"},{"name":"programming","slug":"programming","permalink":"https://shigc.top/tags/programming/"},{"name":"lua","slug":"lua","permalink":"https://shigc.top/tags/lua/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://shigc.top/tags/Wireshark/"},{"name":"network","slug":"network","permalink":"https://shigc.top/tags/network/"},{"name":"vue","slug":"vue","permalink":"https://shigc.top/tags/vue/"},{"name":"web","slug":"web","permalink":"https://shigc.top/tags/web/"},{"name":"光猫","slug":"光猫","permalink":"https://shigc.top/tags/%E5%85%89%E7%8C%AB/"},{"name":"HG2543C1","slug":"HG2543C1","permalink":"https://shigc.top/tags/HG2543C1/"},{"name":"regex","slug":"regex","permalink":"https://shigc.top/tags/regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://shigc.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"python","slug":"python","permalink":"https://shigc.top/tags/python/"},{"name":"scrapy","slug":"scrapy","permalink":"https://shigc.top/tags/scrapy/"},{"name":"android","slug":"android","permalink":"https://shigc.top/tags/android/"},{"name":"proxy","slug":"proxy","permalink":"https://shigc.top/tags/proxy/"},{"name":"c","slug":"c","permalink":"https://shigc.top/tags/c/"},{"name":"git","slug":"git","permalink":"https://shigc.top/tags/git/"},{"name":"github","slug":"github","permalink":"https://shigc.top/tags/github/"},{"name":"linux","slug":"linux","permalink":"https://shigc.top/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://shigc.top/tags/docker/"},{"name":"quagga","slug":"quagga","permalink":"https://shigc.top/tags/quagga/"},{"name":"router","slug":"router","permalink":"https://shigc.top/tags/router/"},{"name":"blog","slug":"blog","permalink":"https://shigc.top/tags/blog/"},{"name":"readme","slug":"readme","permalink":"https://shigc.top/tags/readme/"}]}